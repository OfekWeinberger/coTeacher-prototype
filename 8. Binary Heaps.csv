"start","end","text"
"5960","15020"," (Transcribed by TurboScribe.ai. Go Unlimited to remove this message.) All right, welcome back to 006 Data Structures."
"15960","19260"," Today we're going to cover a different kind"
"19260","21760"," of tree-like data structure called a heap,"
"22100","22720"," binary heap."
"22840","24980"," It's going to let us solve sorting problem"
"24980","25840"," in a new way. "
"26620","30340"," Let me first remind you of a portion."
"30660","31920"," The problem we're going to be solving today"
"31920","33120"," is called a priority queue."
"33540","34560"," This is the interface. "
"34560","36760"," We'll see several data structures, but one main"
"36760","37840"," data structure for today."
"39620","43960"," And this is a subset of the set"
"43960","44500"," interface."
"47320","49540"," And subsets are interesting because potentially we can"
"49540","51960"," solve them better, faster, simpler, something. "
"53860","58040"," And so you'll recognize, you should recognize all"
"58040","60980"," of these operations, except we didn't normally highlight"
"60980","62320"," the max operation."
"62760","64760"," So here we're interested in storing a bunch"
"64760","65300"," of items."
"65300","68920"," They have keys, which we think of as"
"68920","69440"," priorities. "
"70140","71940"," And we want to be able to identify"
"71940","76040"," the maximum priority item in our set and"
"76040","76580"," remove it."
"77460","79060"," And so there's lots of motivations for this."
"79140","80820"," Maybe you have a router, packets going into"
"80820","82740"," the router, they have different priorities assigned to"
"82740","84160"," them, you want to route the highest priority"
"84160","84620"," first. "
"85040","88060"," Or you have processes on your computer trying"
"88060","92280"," to run on your single-threaded, single core,"
"92560","93820"," and you've got to choose which one to"
"93820","96280"," run next, and you usually run higher priority"
"96280","97220"," processes first."
"97700","101980"," Or you're trying to simulate a system where"
"101980","104040"," events happen at different times, and you want"
"104040","106820"," to process the next event ordered by time."
"106920","109400"," All of these are examples of the priority"
"109400","110220"," queue interface. "
"110220","112460"," We'll even see applications within this class when"
"112460","113380"," we get to graph algorithms."
"113980","116000"," But the main two things we want to"
"116000","117620"," be able to support are inserting an item,"
"117680","120300"," which includes a key, and deleting the maximum"
"120300","122300"," item, and also returning it at the same"
"122300","122600"," time."
"123380","126460"," We'll also talk some about being able to"
"126460","129000"," build the structure faster than just inserting it. "
"129039","131100"," But of course we could implement build by"
"131100","133340"," starting empty and repeatedly inserting."
"134100","137220"," And also the complexity of just finding the"
"137220","138300"," max without deleting it."
"138660","140760"," This you could simulate with these two operations"
"140760","142800"," by deleting the max and then reinserting it. "
"144040","145240"," Which works."
"145700","147260"," But often we can do faster."
"148000","151160"," But the two key main operations are insert"
"151160","152300"," and delete max. "
"152480","154980"," And we're going to see a few data"
"154980","156120"," structures to do this."
"157100","159980"," Any suggestions among the data structures we've seen"
"159980","160560"," in this class?"
"160680","164560"," What should we use to solve priority queue"
"164560","165000"," interface?"
"170360","174760"," Many possible answers."
"179030","179770"," Sequence AVL. "
"179850","180590"," Oh, that's interesting."
"181370","183010"," Sequence AVL is a good answer."
"183450","185890"," But it's maybe the fancier version. "
"186950","187230"," Yeah."
"188550","189610"," Set AVL."
"189990","190290"," Sounds good. "
"190850","193630"," Set AVL supports these operations and many more."
"193970","196010"," All in log n time, except for build,"
"196090","198110"," which takes n log n time."
"198170","199330"," Because you have to sort first. "
"200870","202870"," So set AVL is a good way to"
"202870","203130"," do this."
"203250","205810"," We'll come back to your sequence AVL idea"
"205810","206130"," later."
"207530","210710"," This gets log n for operation. "
"211770","211930"," Great."
"212150","214670"," I mean, set AVL is our most powerful"
"214670","215170"," data structure."
"215290","216730"," It does all the operations we care about. "
"217550","218490"," On the set side."
"218590","220090"," And the sequence AVL does all the operations"
"220090","220770"," on the sequence side."
"220830","222190"," But note that this is a set, not"
"222190","222710"," a sequence. "
"222950","223970"," We care about keys."
"224490","225790"," There are hacks to get around that with"
"225790","226570"," sequence AVLs."
"226630","227890"," But let's do that later. "
"230110","230650"," So great."
"230650","233230"," If we wanted to, for example, speed up"
"233230","236310"," find max in a set AVL, we could"
"236310","237730"," add augmentation."
"238530","244490"," We could remember subtree property augmentations. "
"245170","247830"," We can use that to get constant time"
"247830","252610"," find max by storing in every node the"
"252610","255029"," maximum key item within the subtree."
"255450","256630"," And that's a subtree property."
"256690","258529"," It's one we mentioned last class. "
"258529","260750"," So we could even improve that to constant"
"260750","261010"," time."
"261330","261490"," Great."
"262430","263390"," So we're done. "
"263510","264030"," End of lecture."
"264690","266450"," In some sense, that's true."
"266810","268850"," But what we're going to see today is"
"268850","270850"," another data structure called a binary heap, which"
"270850","273950"," is, in some sense, a simplification of set"
"273950","274430"," AVL. "
"274750","277350"," It achieves basically the same time bounds."
"277530","280270"," Build will be faster by a log factor."
"281190","283710"," But that's not the main reason we care"
"283710","284110"," about them. "
"284510","286250"," The main advantage is that they're simpler."
"286890","290050"," And they give us an in-place sorting"
"290050","290450"," algorithm."
"293990","297510"," So I have up here the three of"
"297510","299490"," the operations I've been talking about, build, insert,"
"299630","300390"," and delete max. "
"300870","303390"," So we have set AVL, trees there, n"
"303390","305770"," log n build, log n insert, log n"
"305770","306090"," delete."
"306970","310110"," So along the way to our heap, I"
"310110","312650"," want to mention two other data structures."
"313370","317350"," One is a dynamic but unsorted array. "
"317890","320170"," And the other is a dynamic sorted array."
"325520","328080"," These are simpler data structures we've talked about"
"328080","329000"," many times before."
"329180","332200"," And they're useful motivations for getting started. "
"332260","334660"," Because a heap is going to be built"
"334660","339080"," on top of arrays instead of a fusion"
"339080","340520"," between arrays and trees."
"343480","346560"," So if I have an unsorted array, this"
"346560","348280"," is very easy to insert into."
"348840","351380"," I just append to the end. "
"351380","353100"," This is what we called insert last."
"353580","357900"," So insert is fast, constant amortized."
"358700","360000"," We might have to resize the array. "
"360400","361760"," So that's the amortized part."
"362320","364420"," But delete max is slow in an unsorted"
"364420","364720"," array."
"364800","365860"," I don't know where the maximum is. "
"365900","367340"," So I have to scan through the whole"
"367340","367640"," array."
"370870","373310"," So I scan through the array, identify the"
"373310","374390"," max is somewhere in the middle."
"375250","376910"," And then if I want to delete it,"
"382670","384410"," I want to delete that maximum element. "
"384510","385930"," Well, in a dynamic array, all I can"
"385930","388370"," really do is delete the last element efficiently."
"388710","391030"," So I could, for example, swap it with"
"391030","393130"," the last element."
"393450","395070"," So I take this element and put it"
"395070","398150"," here, and then delete the last element in"
"398150","401050"," that array, which is pop in Python, or"
"401050","402810"," delete last in our world. "
"403550","408130"," So overall, this is linear time, which is"
"408130","408470"," bad."
"409990","411890"," But I wanted to highlight exactly how it's"
"411890","413470"," done for a reason we'll get to in"
"413470","413750"," a moment."
"414330","415950"," Sorted array is sort of the reverse. "
"416230","417690"," It's very easy to find the max."
"418110","418810"," Where is it?"
"421090","421710"," At the end."
"422610","423150"," Delete max. "
"423730","426030"," The maximum element is always the last element"
"426030","428170"," in a increasing sorted array."
"431180","433980"," I guess that's constant amortized, because then I"
"433980","436080"," have to delete it, which may incur resizing."
"438420","442920"," Insert, though, is going to be linear, because"
"442920","444900"," maybe I can binary search to find where"
"444900","447200"," the added item belongs. "
"448060","453440"," Let's say I just added this item here."
"455080","456880"," I could binary search to find it, but"
"456880","457960"," then I'm going to have to do a"
"457960","458480"," big shift."
"458600","460880"," So I might as well just swap repeatedly"
"461600","464700"," until I find the position where the added"
"464700","467200"," item x belongs. "
"467500","469020"," And now I've restored sorted order."
"469180","471780"," That takes linear time, which is bad."
"472180","474000"," And what we want is somehow the best"
"474000","475080"," of these two worlds. "
"475900","477620"," Insert is fast for array."
"479240","481020"," Delete is fast for a sorted array."
"481540","483540"," We can't get constant time for both, but"
"483540","484880"," we can get log n time for both. "
"484940","487700"," We already know how with set AVL trees."
"487860","488800"," But we're going to see a different way"
"488800","489440"," to do it today."
"490680","494400"," And the main motivation for a different way"
"494400","497420"," to do this is sorting. "
"498280","501340"," So I want to define priority queue sort."
"509280","512580"," So given any data structure that implements a"
"512580","515380"," priority queue interface, in particular, insert and delete"
"515380","517720"," max, I can make a sorting algorithm."
"518080","518799"," What do I do?"
"519220","521720"," Insert all the items, delete all the items. "
"522240","524280"," But because when I delete them, they come"
"524280","526900"," out largest first, I get them in reverse"
"526900","527440"," sorted order."
"527600","529720"," Then I could reverse in linear time, and"
"529720","531000"," I've sorted my items."
"531600","538440"," So we can insert x for x and"
"538440","547500"," a, or build a, and then repeatedly"
"547500","549600"," delete max. "
"556920","558720"," How much time does this algorithm take?"
"559400","561160"," I'm going to introduce some notation here."
"561300","563420"," It takes however long it takes to build"
"563420","564040"," n items."
"564880","568500"," I'll call that t sub build of n"
"568500","580780"," plus n times the"
"580780","582040"," time to do a delete max. "
"585570","588810"," Or we can write this as n times"
"588810","592870"," time to do an insert plus time to"
"592870","593630"," do a delete max."
"598070","600050"," So I'm using these t functions to just"
"600050","603490"," abstract what are the running times provided by"
"603490","605770"," my data structure that implements this interface."
"606070","608230"," Interface says what's correct is, and these t"
"608230","610250"," functions give me my performance bounds. "
"610770","612550"," So if I plug in each of these"
"612550","615590"," data structures, I get a sorting algorithm."
"616550","617590"," I get AVL sort."
"617730","618710"," I get array sort. "
"618830","619990"," I get assorted array sort."
"620210","621550"," What do those look like?"
"621590","623190"," It turns out many of these are familiar."
"625910","629050"," So set AVLs take log n per operation. "
"629470","631670"," So we get an n log n sorting"
"631670","634690"," algorithm out of them, which is insert all"
"634690","636330"," of the items into the AVL tree."
"636490","638250"," I don't want to use AVL build because"
"638250","639330"," that uses sort."
"639610","640990"," I'm not allowed to sort in order to"
"640990","641510"," implement sort. "
"642030","643490"," But we saw how to insert into an"
"643490","645050"," AVL tree and keep the thing balanced."
"645610","647050"," So that takes log n each."
"647450","649770"," And then we can find the max, delete"
"649770","651350"," it, rebalance, and so on. "
"651450","652670"," Total time will be n log n."
"652750","654430"," This is an algorithm we call AVL sort."
"655470","657610"," It's a bit complicated because AVL trees are"
"657610","657990"," complicated."
"657990","661910"," But it gives us optimal comparison bound, n"
"661910","662250"," log n."
"665490","667950"," Now, what about array sort?"
"668250","671170"," So suppose I use an unsorted array. "
"672990","674310"," I insert the item."
"674530","676290"," So if I insert the items, so I'm"
"676290","677850"," doing all the insertions here before all the"
"677850","678270"," deletions."
"678410","679490"," So what's going to happen is I just"
"679490","681490"," insert the items in the original array order. "
"681650","682890"," In other words, I just take the array."
"683570","687250"," And then what I do is repeatedly extract"
"687250","692970"," the maximum item by searching for it, moving"
"692970","694730"," it to the end of the array, and"
"694730","696010"," then repeating that process."
"696110","696730"," That sound familiar?"
"698170","701930"," That's selection sort from lecture three. "
"703850","707630"," So this arrays give us selection sort."
"713180","714620"," This is a new way to think about"
"714620","716280"," what we were doing way back then."
"716740","721060"," With a sorted array, what are we doing?"
"721060","722700"," We insert all the items. "
"722940","724860"," That's actually where all the work happens because"
"724860","726140"," we maintain the sorted array."
"726480","727780"," So we start with an empty array."
"727880","728300"," It's sorted. "
"728540","729320"," We add an item."
"729500","730140"," OK, still sorted."
"730220","731040"," We add a second item. "
"731080","732780"," And we swap if we need to in"
"732780","733260"," order to sort."
"733420","735160"," In general, when we add an item, we"
"735160","736960"," swap it to the left until it's sorted"
"736960","737240"," again."
"737440","739720"," That is insertion sort. "
"745760","746540"," Kind of cool."
"746920","750540"," This is a unifying framework for three sorting"
"750540","752080"," algorithms that we saw before."
"752240","754520"," We didn't actually talk about AVL sort last"
"754520","755540"," time, but it was in the notes. "
"755960","758120"," And so that is the right part of"
"758120","758580"," this table."
"758980","761600"," So of course, these array data structures are"
"761600","762120"," not efficient."
"762400","764160"," They take linear time for some of the"
"764160","766040"," operations, so the sorting algorithms are not efficient. "
"766480","767960"," But they're ones we've seen before, so it's"
"767960","769180"," neat to see how they fit in here."
"770000","771940"," They had the selection sort and insertion sort"
"771940","773660"," had the advantage that they were in place."
"773740","775680"," You just needed a constant number of pointers"
"775680","778860"," or indices beyond the array itself. "
"779380","780620"," So they're very space efficient."
"780980","782300"," So that was a plus for them."
"782380","783980"," But they take n squared time, so you"
"783980","784760"," should never use them. "
"785320","787440"," Except for n at most 100 or something."
"789380","792040"," AVL tree sort is great in that it"
"792040","793020"," gets n log n time."
"793480","796020"," Probably more complicated than merge sort, and you"
"796020","796900"," could stick to merge sort. "
"797360","799700"," But neither merge sort nor set AVL tree"
"799700","801440"," sort are in place."
"802020","804700"," And so the goal of today is to"
"804700","806240"," get the best of all those worlds in"
"806240","808720"," sorting to get n log n comparisons, which"
"808720","811320"," is optimal in the comparison model, but get"
"811320","812440"," it to be in place."
"812440","814840"," And that's what we're going to get with"
"814840","815620"," binary heaps. "
"818500","821120"," We're going to design a data structure that"
"821120","822780"," happens to build a little bit faster, as"
"822780","824020"," I mentioned, linear time building."
"825260","827580"," So it's not representing a sorted order in"
"827580","828960"," the same way that AVL trees are."
"829640","831260"," But it will be kind of tree based. "
"831340","832860"," It will also be array based."
"833540","835720"," We're going to get logarithmic time for insert"
"835720","836500"," and delete max."
"836620","838240"," This happens to be amortized because we use"
"838240","838580"," arrays. "
"839940","842060"," But the key thing is that it's an"
"842060","843540"," in-place data structure."
"843940","846280"," It only consists of an array of the"
"846280","846640"," items."
"847900","849360"," And so when we plug it into our"
"849360","852760"," sorting algorithm, priority queue sort, our generic sorting"
"852760","854840"," algorithm, not only do we get n log"
"854840","856700"," n performance, but we also get an in "
"856700","858380","-place sorting algorithm. "
"858520","860540"," This will be our first and only in"
"860540","863020"," this class, n log n in-place sorting"
"863020","863320"," algorithm."
"864340","864820"," Cool."
"867150","867950"," That's the goal. "
"867950","868050"," Cool."
"869990","871150"," Let's do it."
"871310","875950"," So what we're going to do, because we're"
"875950","877650"," in place, basically we have to have an"
"877650","879550"," array storing our n items. "
"879710","881450"," That's sort of the definition of in-place,"
"881610","884950"," just using n slots of memory, exactly the"
"884950","887130"," size of the number of items in our"
"887130","887450"," structure."
"887830","889310"," But we're obviously not going to use a"
"889310","891990"," regular unsorted array or a regular sorted array."
"892850","894490"," We're going to use array just as sort"
"894490","897630"," of the underlying technology for how things are"
"897630","897930"," stored. "
"897970","901070"," But we'd really like logarithmic performance, which should"
"901070","902130"," make you think tree."
"902670","904250"," Only way to get a log is with"
"904250","905450"," the binary tree, more or less."
"907870","908950"," So tree. "
"909530","913710"," Somehow, we want to embed a tree into"
"913710","914070"," an array."
"914650","916110"," Let me grab an example."
"923620","926300"," Let me draw a tree. "
"944320","946200"," If I got to choose any old tree"
"946200","949320"," I want, I would choose a tree that's"
"949320","951120"," basically perfectly balanced."
"951340","955300"," Perfectly balanced would be like this, where what's"
"955300","955800"," the property?"
"956060","959040"," That I have all of these levels, all"
"959040","961360"," of these depths are completely filled with nodes."
"961600","963060"," This is depth 0."
"965420","967300"," Remember, this is depth 1."
"967660","968780"," This is depth 2."
"969260","970580"," This is depth 3."
"971220","974080"," So what I'd really like is to have"
"974080","979440"," 2 to the i nodes at depth i."
"980520","983820"," That would be a perfect binary tree. "
"984960","987040"," But that only works when n is 1"
"987040","987960"," less than a power of 2."
"988640","991140"," I can't always achieve that for any n."
"991660","993180"," And so the next best thing I could"
"993180","996120"," hope for is 2 to the i nodes"
"996120","998300"," at depth i until the very last i,"
"998400","999320"," the largest depth."
"999980","1002860"," And in that level, I'm still going to"
"1002860","1003560"," restrict things."
"1003660","1005320"," I'm going to force all of the nodes"
"1005320","1006900"," to be as far left as possible. "
"1008600","1013720"," So I want to say, except at max"
"1013720","1023720"," depth, where nodes are, I'll"
"1023720","1024740"," call them, left justified."
"1026020","1033220"," And these two properties together is what I"
"1033220","1035119"," call a complete binary tree."
"1047430","1048770"," Why is this interesting?"
"1049370","1052310"," Because I claim I can represent a tree"
"1052310","1053990"," like this as an array. "
"1055090","1058710"," I've narrowed things down enough that I can"
"1058710","1059910"," draw an array down here."
"1060950","1062750"," And what I'm going to do is write"
"1062750","1064430"," these nodes in depth order."
"1065150","1067050"," So I'll write a first, because that's depth"
"1067050","1067370"," 0."
"1067670","1069650"," Then bc, that's depth 1."
"1070770","1073030"," Then, well, they're alphabetical. "
"1073110","1074090"," I made it that way."
"1076070","1077810"," defg is depth 2."
"1078450","1080650"," And then hij is depth 3."
"1082930","1085590"," This is very different from traversal order of"
"1085590","1085870"," a tree."
"1086270","1088150"," Traversal order would have been h, d, i,"
"1088170","1090510"," b, j, e, a, f, c, g."
"1091290","1093550"," OK, but this is what we might call"
"1093550","1094150"," depth order. "
"1095090","1096730"," Do the lowest depth nodes first."
"1097610","1100030"," Very different way to lay things out or"
"1100030","1102250"," to linearize our data."
"1104090","1106510"," And this is what a heap is going"
"1106510","1107030"," to look like. "
"1107250","1113210"," So the cool thing is, between complete binary"
"1113210","1116190"," trees and arrays is a bijection."
"1116350","1119030"," For every array, there's a unique complete binary"
"1119030","1119410"," tree."
"1119410","1121590"," And for every complete binary tree, there's a"
"1121590","1122150"," unique array. "
"1123270","1123630"," Why?"
"1123890","1128230"," Because the complete constraint forces everything, forces my"
"1128230","1128470"," hand."
"1128590","1130230"," There's only, if I give you a number"
"1130230","1132890"," n, there is one tree shape of size"
"1132890","1133190"," n."
"1133590","1136610"," You just fill in the nodes, top down,"
"1136690","1137750"," until you get to the last level."
"1137830","1138770"," And then you have to fill them in"
"1138770","1141170"," left to right, what you might call reading"
"1141170","1143410"," order for writing down nodes. "
"1143630","1146330"," And the array is telling you which keys"
"1146330","1146770"," go where."
"1147030","1148490"," This is the first node you write down"
"1148490","1148910"," at the root."
"1148910","1150670"," This is the next node you write down"
"1150670","1152230"," at the left child of the root, and"
"1152230","1152650"," so on. "
"1153490","1156090"," So here we have a binary tree represented"
"1156090","1158630"," as an array, or an array representing a"
"1158630","1159150"," binary tree."
"1159510","1162430"," The very specific binary tree, it has a"
"1162430","1165410"," clear advantage, which is it is guaranteed balanced."
"1165550","1168510"," No rotation is necessary in heaps, because complete"
"1168510","1169730"," binary trees are always balanced. "
"1169830","1171370"," In fact, they have the best height they"
"1171370","1175310"," possibly could, which is ceiling of log n."
"1179530","1181310"," Balanced, remember, just meant you were big O"
"1181310","1181830"," of log n."
"1182130","1184270"," This is 1 times log n."
"1184330","1186830"," So it's the best level of balance you"
"1186830","1187330"," could hope for."
"1187750","1191390"," So somehow, I claim, we can maintain a"
"1191390","1194130"," complete binary tree for solving priority queues."
"1194190","1195570"," This would not be possible if you were"
"1195570","1197050"," trying to solve the whole set interface. "
"1197610","1198870"," And that's kind of the cool thing about"
"1198870","1201130"," heaps, is that by just focusing on the"
"1201130","1204550"," subset of the set interface, we can do"
"1204550","1204910"," more."
"1204910","1206970"," We can maintain this very strong property."
"1207730","1209270"," And because we have this very strong property,"
"1209370","1210750"," we don't even need to store this tree. "
"1210890","1212130"," We're not going to store left and right"
"1212130","1213930"," pointers and parent pointers."
"1214150","1215430"," We're just going to store the array."
"1216330","1219090"," This is what we call an implicit data"
"1219090","1228860"," structure, which"
"1228860","1237840"," basically means no pointers, just an array of"
"1237840","1238620"," the n items. "
"1243830","1245330"," How are we going to get away without"
"1245330","1246010"," storing pointers?"
"1246590","1248350"," I'd still like to treat it like a"
"1248350","1248590"," tree."
"1248730","1251150"," I'd still like to know the left child"
"1251150","1252870"," of B is D and the right child"
"1252870","1253750"," of B is E."
"1254050","1255350"," We'll see why in a moment."
"1256310","1261010"," Well, we can do this with index arithmetic. "
"1263410","1266110"," So maybe I should add some labels before"
"1266110","1266550"," I get there."
"1270980","1273560"," So this array naturally has indices."
"1274020","1275160"," This is index 0."
"1276240","1278900"," This is index 1, index 2, index 3,"
"1279320","1282680"," index 4, index 5, index 6, 7, 8,"
"1283040","1286340"," 9, because there are 10 items, 0 through"
"1286340","1286640"," 9."
"1287580","1289360"," And I can apply those labels up here,"
"1289420","1289540"," too. "
"1289620","1290540"," These are the same nodes."
"1290620","1292440"," So 0, 1, 2."
"1292520","1294140"," This is just depth order."
"1296620","1298260"," But once I have this labeling, it's going"
"1298260","1299440"," to be a lot easier to figure things"
"1299440","1299660"," out. "
"1299920","1301160"," So if I wanted to know the left"
"1301160","1303800"," child of B is D, somehow, given the"
"1303800","1306180"," number 1, I want to compute the number"
"1306180","1306520"," 3."
"1306520","1312600"," 3, add 2, multiply by 3."
"1312720","1314280"," There are all sorts of operations that take"
"1314280","1315420"," 1 and turn it into 3."
"1315660","1317240"," But there's only one that's going to work"
"1317240","1318000"," in all cases."
"1318560","1320440"," And the intuition here is, well, I have"
"1320440","1322040"," 2 to the i nodes at level i."
"1322480","1323740"," If I want to go to the child"
"1323740","1325720"," level, there's 2 to the i plus 1"
"1325720","1327760"," nodes down there, exactly double."
"1328260","1329920"," Except the very last one, but that won't"
"1329920","1330860"," really matter. "
"1330960","1332220"," If there is a left child, it will"
"1332220","1332860"," behave the same."
"1333360","1335000"," And so intuitively, I have this space of"
"1335000","1335700"," size 2 to the i."
"1335700","1337140"," I have to expand it to a space"
"1337140","1338840"," of size 2 to the i plus 1."
"1339260","1340980"," So I should multiply by 2."
"1342240","1343520"," And that's almost right."
"1343780","1345880"," But then there's some constants. "
"1346860","1348880"," So I'd like to say 2 times i."
"1349360","1351500"," But if we look at the examples here,"
"1351900","1354620"," 1 times 2 is 2, which is 1"
"1354620","1355200"," less than 3."
"1355980","1357780"," 2 times 2 is 4, which is 1"
"1357780","1358300"," less than 5."
"1358360","1359640"," Hey, we almost got it right."
"1359680","1360480"," It's just off by 1."
"1364440","1367120"," 1 is index errors are the most common"
"1367120","1368220"," things in computer science."
"1370560","1371740"," What about the right child?"
"1374070","1375510"," If the left child is a 2i plus"
"1375510","1376490"," 1, where's the right child?"
"1379540","1380380"," I hear lots of mumbles. "
"1380480","1381280"," 2i plus 2."
"1383120","1383800"," One more."
"1383940","1385540"," Because we're writing things left to right in"
"1385540","1388300"," depth order, the right child is the right"
"1388300","1389620"," sibling of the left child."
"1389640","1390980"," So it's just one larger. "
"1391780","1395420"," Given those rules, we can also compute parent."
"1395780","1398380"," It's just whatever is the inverse of both"
"1398380","1402960"," of these functions, which I want to divide"
"1402960","1404380"," by 2 at some point."
"1404960","1406840"," But I want to get back to i"
"1406840","1408720"," given 2i plus 1 or given 2i plus"
"1408720","1408980"," 2."
"1409460","1414680"," And so if I subtract 1 from i,"
"1415840","1417560"," then I either get 2i or 2i plus"
"1417560","1417820"," 1."
"1418060","1420000"," And then if I take an integer division"
"1420000","1423260"," by 2, I get i, the original i."
"1423640","1425780"," Sorry, maybe I'll call this j to be"
"1425780","1426080"," clearer. "
"1426700","1428820"," So j is the left or right child."
"1429380","1431520"," Then I can reconstruct i, which was the"
"1431520","1431760"," parent."
"1433020","1436000"," So this is a constant number arithmetic operation. "
"1436160","1438160"," So I don't have to store left and"
"1438160","1438540"," right pointers."
"1438620","1440100"," I can just compute them whenever I need"
"1440100","1440300"," them."
"1440420","1443300"," Whenever I'm at some node like E, and"
"1443300","1444660"," I want to know what's its left child,"
"1445500","1448800"," sorry, given the node index 4, which happens"
"1448800","1451560"," to contain the item E, and I want"
"1451560","1452760"," to know what's its left child, I just"
"1452760","1453780"," multiply by 2 and add 1."
"1453840","1454360"," I get 9."
"1454880","1456600"," Then I can index into this array at"
"1456600","1458640"," position 9, because this is just in my"
"1458640","1458920"," head. "
"1459000","1461920"," Remember, we're just thinking that there's a tree"
"1461920","1462220"," here."
"1462520","1464800"," But in reality, on the computer, there's just"
"1464800","1465220"," the array."
"1466160","1467780"," So if we want to go from E"
"1467780","1469820"," to j, we can, from 4 to 9."
"1470400","1472040"," If we try to go to the right"
"1472040","1474540"," child, we multiply by 2, 8, add 2,"
"1474740","1475060"," 10. "
"1475380","1476920"," And we see, oh, 10 is beyond the"
"1476920","1477520"," end of the array."
"1477800","1479080"," But our array stores its size."
"1479140","1480720"," So we realize, oh, E does not have"
"1480720","1481260"," a right child. "
"1481900","1483600"," This is something you can only do in"
"1483600","1484540"," a complete binary tree."
"1485000","1486660"," In a general binary tree, you don't have"
"1486660","1487400"," these nice properties."
"1489660","1490100"," Cool. "
"1491200","1493860"," So this is basically a heap."
"1493920","1495860"," I just need to add one more property,"
"1498350","1499930"," naturally, called the heap property."
"1506200","1509300"," So there are multiple types of heaps. "
"1509520","1511120"," This type of heap is called a binary"
"1511120","1511420"," heap."
"1511840","1513760"," We will talk about others in future lectures."
"1514580","1515760"," I'm going to call it Q."
"1518080","1527900"," Maybe I should write the explicit"
"1527900","1528300"," thing. "
"1528580","1533260"," This is an array representing a complete binary"
"1533260","1548660"," tree called the"
"1548660","1549160"," array Q."
"1549540","1557680"," And we want every node to satisfy"
"1557680","1576970"," the so-called max heap property, which"
"1576970","1580870"," says Q of i is greater than or"
"1580870","1585490"," equal to Q of j for both children"
"1585490","1589830"," left of i and right of i."
"1598040","1603180"," So we have a node, i, and has"
"1603180","1606440"," two children, 2i plus 1 and 2i plus"
"1606440","1606720"," 2."
"1607940","1610200"," These are our two values of j."
"1613080","1615920"," What we want is a greater than or"
"1615920","1618740"," equal to relation here and here."
"1619900","1621520"," So this node should be bigger than both"
"1621520","1622300"," this one and this one."
"1622500","1623520"," Which of these is larger?"
"1623780","1624440"," We don't know. "
"1624540","1625340"," And we don't care."
"1626120","1628740"," Very different from binary search trees or set"
"1628740","1631300"," binary trees, where we said these guys were"
"1631300","1632680"," less than or equal to this one."
"1632940","1634080"," This one was less than or equal to"
"1634080","1635220"," all the nodes in the subtree. "
"1635220","1637300"," Here, we're just locally saying this node is"
"1637300","1639160"," greater than or equal to this node and"
"1639160","1639640"," this node."
"1640060","1641700"," So the biggest is at the top."
"1645880","1650980"," So one nice lemma about these heaps, this"
"1650980","1651600"," is weird. "
"1653660","1655240"," Let me give you some more intuition."
"1656460","1658260"," If you are a binary heap, if you"
"1658260","1660960"," satisfy this max heap property everywhere, then, in"
"1660960","1664960"," fact, you learn that every node i is"
"1664960","1667620"," greater than or equal to all nodes in"
"1667620","1668120"," its subtree."
"1668260","1675140"," These are what we call descendants and subtree"
"1675140","1675700"," of i."
"1680100","1683040"," Let me look at this example. "
"1683300","1685000"," So I haven't written any numbers here, but"
"1685000","1685760"," you can imagine."
"1686400","1689040"," So a here is greater than or equal"
"1689040","1690100"," to both b and c."
"1690760","1692000"," And b is greater than or equal to"
"1692000","1692580"," d and e."
"1692580","1694020"," And c is greater than or equal to"
"1694020","1694580"," f and g."
"1695000","1695820"," And d is greater than or equal to"
"1695820","1696300"," h and i."
"1696340","1697240"," And e is greater than or equal to"
"1697240","1697440"," j."
"1697600","1700200"," That would make this structure a heap, not"
"1700200","1701320"," just a complete binary tree."
"1703400","1704520"," So what does that imply?"
"1704640","1706580"," It implies that a must be the maximum. "
"1707200","1708600"," So you look at any node here, like"
"1708600","1710860"," j, a is greater than or equal to"
"1710860","1712140"," b, is greater than or equal to e,"
"1712200","1713220"," is greater than or equal to j."
"1714300","1716160"," And in general, what we're saying is that"
"1716160","1717800"," a is greater than or equal to all"
"1717800","1718440"," nodes in the tree."
"1718780","1719940"," b is greater than or equal to all"
"1719940","1721700"," nodes in its subtree, down here."
"1722380","1723400"," c is greater than or equal to all"
"1723400","1724200"," nodes in its subtree. "
"1724540","1726100"," That's what this lemma is saying."
"1726940","1729360"," You can prove this lemma by induction."
"1730680","1732640"," But it's really simple. "
"1734980","1736740"," If you have two nodes, i and j,"
"1736840","1738940"," and j is somewhere in the subtree, that"
"1738940","1743100"," means there's some downward path from i to"
"1743100","1743400"," j."
"1743740","1745620"," And you know that for every edge we"
"1745620","1748200"," traverse on a downward path, our key is"
"1748200","1750200"," going down non-strictly."
"1750700","1752160"," Every child is less than or equal to"
"1752160","1752620"," its parent."
"1753080","1754060"," i is greater than or equal to this,"
"1754100","1755040"," is greater than or equal to this, is"
"1755040","1755840"," greater than or equal to this, is greater"
"1755840","1756440"," than or equal to j."
"1757760","1761120"," So by transitivity of less than or equal"
"1761120","1763060"," to, you know that i is, in fact,"
"1763120","1764200"," greater than or equal to j."
"1764740","1766880"," Or sorry, the key in i is greater"
"1766880","1768300"," than or equal to the key in j."
"1768820","1770700"," This is what we're calling i, the index. "
"1770840","1772800"," This is what we would call q of"
"1772800","1773120"," i."
"1774120","1776920"," This is index j, q of j."
"1779420","1779900"," OK."
"1779980","1784780"," Very different way to organize keys in a"
"1784780","1784980"," tree."
"1786420","1789320"," But as you might imagine, this is going"
"1789320","1791080"," to be good for priority queues, because priority"
"1791080","1793460"," queues just need to find the maximum element. "
"1794520","1795580"," Then they need to delete it."
"1795620","1797260"," That's going to be harder, because deleting the"
"1797260","1798980"," root is like, that's the hardest node. "
